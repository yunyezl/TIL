# Chapter2. 명세 기반 테스트

- 요구사항 : 어떤 기능이 무엇을 해야 하느지를 설명해는 텍스트 문서
- 명세 테스트란 요구 사항 자체에서 테스트를 도출하는 것. 당장의 구체적인 구현은 덜 중요함.

## 2.1 요구사항이 모든 걸 말한다

- **요구사항** : 주어진 문자열에서 두 태그 사이에 존재하는 모든 부분 문자열을 반환한다.
- 이 요구사항을 만족할 메서드에 대해 다음과 같은 요구사항을 도출
    - 메서드: `substringsBetween`
    - 어떤 문자열에서 start와 end 태그로 구분되는 부분 문자열을 모두 찾아서 배열로 반환한다.
    - `str`: 주어진 문자열, 이게 널일 경우 널을 반환한다. 빈 문자열이라면 빈 배열을 반환한다.
    - `open`: 찾으려는 문자열의 시작을 가리키는 문자열. 이게 빈 문자열이면 널을 반환한다.
    - `close`: 찾으려는 문자열의 끝을 가리키는 문자열. 이게 빈 문자열이면 널을 반환한다.

```java
public static String[] substringsBetween(final String str, final String open, final String close) {
    if (str == null || isEmpty(open) || isEmpty(close)) {
        return null;
    }

    int strLen = str.length();
    if (strLen == 0) {
        return EMPTY_STRING_ARRAY;
    }

    int closeLen = close.length();
    int openLen = open.length();
    List<String> list = new ArrayList<>();
    int pos = 0;

    while (pos < strLen - closeLen) {
        int start = str.indexOf(open, pos);
        if (start < 0) {
            break;
        }

        start += openLen;
        int end = str.indexOf(close, start);
        if (end < 0) {
            break;
        }

        list.add(str.substring(start, end));
        pos = end + closeLen;
    }

    if (list.isEmpty()) {
        return null;
    }

    return list.toArray(EMPTY_STRING_ARRAY);
}
```
- 입력값 str = "axcaycazc"
- open = "a"
- close = "c"

**요구사항을 살펴보고 생각해낼 수 있는 테스트 케이스 도출해보기 (내 생각)**
- open, close가 붙어있는 경우 (ex. acac)
- open, close가 반대로 되어있는 경우 (ex. ca)
- open, close가 없는 경우 (ex. xxx)
- open, close 둘 중 하나만 있는 경우
- 부분 문자열이 없는 경우
- 부분 문자열이 1개인 경우
- 부분 문자열이 2개 이상인 경우

### 2.1.1 1단계: 요구사항과 입출력에 대해 이해하기
요구사항은 세 부분으로 이루어진다.
1. 프로그램 또는 메서드는 무엇을 수행하는 가 (비즈니스 규칙))
2. 프로그램은 데이터를 입력으로 받는다.
3. 출력에 대한 추론은 프로그램이 무엇을 수행하고 입력이 어떻게 기대하는 출력으로 변환되는지 더 잘 이해하도록 해준다.

### 2.1.2 2단계: 여러 입력값에 대해 프로그램이 수행하는 바를 탐색하기
- 메서드가 수행하는 작업을 탐색하면 메서드를 더 잘 이해할 수 있음.
- 직접 만들지 않은 코드에 작성하는 테스트라면 더 유용함
- 여러 테스트 케이스를 넣어가며 프로그램이 동작하는 바에 대해 파악하는 것임

### 2.1.3 3단계: 테스트 가능한 입출력과 구획을 탐색하기
- 프로그램은 일부 입력 집합에 대해 특정 입력값에 관계없이 동일한 방식으로 동작한다. 이런 입력을 **동등하다**고 한다.
- 입력값에 대한 구획을 나누어 식별하여 테스트가 되지 않은 다른 부류를 찾아야한다. 도메인을 계속 분할해나가면, 입력에 대한 모든 구획을 찾아낼 수 있다.
- 이러한 탐색을 체계적으로 하는 방법은 다음과 같다.
    - 각각의 입력에 대해: *"내가 전달하는 입력이 어떤 부류에 해당하는가?"*
    - 각 입력과 다른 입력의 조합에 대해: *"open 태그와 close 태그 사이에 어떤 조합을 만들 수 있을까?"*
    - 이 프로그램에서 기대하는 여러 부류의 출력에 대해: *"배열을 리턴하는가? 빈 배열을 리턴할 수 있을까? 널을 리턴할 수 있을까?"*
- 개별 입력으로 시작하는 것이 가장 쉽다.
    - str, open, close이 각각 널 문자열인 경우 / 빈 문자열인 경우 / 길이가 1인 문자열인 경우 / 길이가 1보다 큰 문자열인 경우
    - (str, open, close) 매개변수
        a. str이 open, close 태그를 모두 포함하고 있는 경우
        b. str이 open 태그만 포함하고 close 태그는 포함하지 않는 경우
        c. str이 close 태그만 포함하고 open 태그는 포함하지 않는 경우
        d. str이 open, close 태그 둘 다 포함하는 경우
        e. str이 open, close 태그 둘 다를 여러 번 포함하는 경우
- 출력
    - 문자열 배열
        a. 널 배열인 경우
        b. 빈 배열인 경우
        c. 요소가 하나인 경우
        d. 요소가 여러 개 인경우
    - 각각의 개별 문자열
        a. 빈 문자열인 경우
        b. 문자가 하나인 경우
        c. 여러 문자로 되어 있는 경우

### 2.1.4 4단계: 경계 분석하기
- 소프트웨어 시스템에서 버그는 입력 도메인의 경계에서 흔히 발생함
- 경계가 있을 때마다 두 점 테스트를 수행하자
    - 하나는 **경계 위에 있는 접점**과 **거점**에 대한 테스트
        - 거점은 접점이 속해있지 않은 구획에 있으면서 경계에 가장 가까운 점
    - **내점**과 **외점** 테스트
        - 내점은 조건이 참인 점
        - 외점은 조건이 거짓인 점
- 앞의 케이스에는 다음과 같은 경계들이 있음
    - 부분 문자열 없음
    - 부분 문자열 하나
    - 부분 문자열 여러 개
    - open / close 태그가 문자열에 없음
    - 부분 문자열이 없음

### 2.1.5 5단계: 테스트 케이스 고안하기
- 앞선 케이스들의 경우, 총 320개의 조합이 나옴
- 이 모든 케이스를 테스트할 수는 없음
- 구획을 어떻게 조합할지 실용적으로 결정해야 함

2.2, 2.3 생략

## 2.4 현업에서의 명세 테스트

### 2.4.1 프로세스는 연속적이 아니라 반복적이어야 한다
종종 테스트 케이스를 작성할 때 구획이나 경계를 놓쳤다는 것을 알면 다시 돌아가서 테스트 케이스를 개선한다.

### 2.4.2 명세 테스트는 어느 정도로 수행해야 하는가?
실패의 위험성을 이해해야 한다. 프로그램이 어떤 부분에서 실패하면 비용이 얼마나 들까? 비용이 높은 경우라면 테스트에 더 투자를 하고, 더 많은 코너 케이스를 탐색하고, 품질을 보장하기 위해 다양한 기술을 시도하는 것이 현명할 수 있다. 하지만 비용이 낮다면 덜 꼼꼼하게 해도 충분할지도 모른다.

### 2.4.3 구획인가, 경계인가? 그것은 중요하지 않다
입력과 출력을 탐색하고 구획을 식별하며 테스트 케이스를 고안할 때, 경계를 두 구획 사이의 경계가 아닌 배타적 구획으로 간주할 수 있다. 구획을 식별하거나 경계 테스트 단계에서 특별한 경우가 나타나도 상관없다. 각 개발자는 명세를 다르게 해석할 수도 있고 사소한 변화가 생길 수도 있다. 중요한 것은 테스트가 도출되고 버그가 프로그램에 스며들지 않는다는 점이다.

### 2.4.4 접점과 거점으로도 충분하지만, 내점과 외점도 얼마든지 추가하자
- 접접, 거점은 내점, 외점이 수행하는 동일한 구획을 수행하므로 중복일 수 있지만, 이를 추가함으로써 프로그램을 더 잘 이해하고 실제 입력을 더 잘 나타낼 수 있음.
- 그러나 테스트 케이스를 가볍게 유지하는 것도 좋은 생각임.

### 2.4.5 이해를 높이기 위해 입력을 변경해서 사용하자
- 테스트의 일관성 유지
    - 모든 테스트에 동일한 입력 시드(input seed) 를 사용하면 테스트 케이스를 이해하기 쉬워진다.
    - 예: "abc"라는 문자열을 기반으로 다양한 테스트를 수행.
- 구획별 작은 수정
    - 특정 구획의 기준을 충족할 수 있도록 입력 값을 조금씩 수정해 테스트를 수행한다.
    - 예: "abc" → "aBc", "abcd", "abc!" 등
- 입력 다양성의 필요성 (⚠️주의점)
    - 하지만 이 방법은 다양한 입력값을 테스트해야 하는 일반적인 원칙에 어긋날 수 있다.
    - 다양한 입력을 사용해야 코너 케이스(corner case) 를 찾을 수 있다.

### 2.4.6 조합의 수가 폭발적으로 증가한다면 실용적이여야 한다
- 가능한 조합의 수를 줄이도록 하자. 도메인 지식을 활용하거나, 다른 동작과 동떨어진 예외적인 동작을 테스트한다.
- 메서드 수준에서 많은 조합이 발생한다면 메서드를 두 개로 나누는 것을 고려하자. 

### 2.4.7 무엇을 입력할지 모르겠다면 간단한 입력을 넣어보자
- 현실적이면서도 테스트가 실패할 경우 디버깅을 용이할 수 있게 하는 간단한 값을 선택하는 것이 유리하다

### 2.4.8 관심 없는 입력에 대해 합리적인 값을 선택하자
- 때로는 기능의 특정 부분을 수행하는 것을 목표로 하고, 그 부분은 입력값 중 하나를 사용하지 않을 수 있다. 이 경우에 아무 값이나 전달하지 말고, 현실적인 값을 전달하라.

### 2.4.9 널과 예외 케이스는 의미가 있을 때만 사용하자
- 테스트 중인 코드가 UI와 매우 관련이 있는 경우라면 널, 빈 문자열, 일반적이지 않은 정숫값 등과 같은 코너 케이스를 더 많이 수행하라.

### 2.4.10 테스트가 동일한 스켈레톤을 갖는 경우 매개변수화 테스트를 사용하자
