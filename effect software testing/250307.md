# Chapter 5. 속성 기반 테스트

**속성 기반 테스트**란 구체적인 예를 고르는 대신 프로그램이 지켜야 하는 속성을 정의하면, 테스트 프레임워크는 이 속성으로 프로그램을 깨뜨릴 수 있는 반례를 찾아주는 것이다. 

## 예제: 합격 등급 프로그램

> 학생들은 grade ≥ 5.0이면 시험을 통과한다. 그 아래 점수는 시험에서 떨어진다. 등급은 [1.0, 10.0]의 범위에 있다.
> 

이 프로그램을 단순하게 구현하면 다음과 같다.

```jsx
public class PassingGrade {
	public boolean passed(float grade) {
		if (grade < 1.0 || grade > 10.0)
			throw new IllegalArgumentException();
		return grade >= 5.0;
	}
}
```

이 프로그램에 명세 기반 테스트를 적용하면 `합격 등급`, `실패 등급`, `범위 밖의 등급`과 같이 구획을 나눌 수 있을 것이다. 그런 다음 구획마다 하나씩 테스트 케이스를 고안할 것이다. 속성 기반 테스트를 통해 프로그램이 가져야 하는 속성을 정하면 앞의 요구사항에 대해 다음과 같은 속성을 찾을 수 있다.

- **fail** : 1.0(포함)에서 5.0(제외)까지의 범위에 있는 모든 수에 대해 프로그램은 `false`를 반환한다.
- **pass** : 5.0(포함)에서 10.0(포함)까지의 범위에 있는 모든 수에 대해 프로그램은 `true`를 반환한다.
- **invalid** : 유효하지 않은 모든 등급(1.0 미만이거나 10.0 초과인 어떤 수)에 대해, 프로그램은 예외를 던진다.

속성은 무작위로 생성된 데이터를 사용하며 다양한 제약 조건 세트를 정의할 수 있고 매개변수에 제약을 가할 수 있다. 예를 들어 양수인 Integer 또는 길이가 5에서 10인 문자들로 이루어진 String만 생성하도록 할 수 있다. 이 무작위 값을 통해 속성에 대한 반례를 찾아낼 수 있는 것이다.

## 예제 2: unique 메서드 테스트

주어진 데이터의 유일한 값으로 구성된 배열을 반환한다. 반환되는 배열은 내림차순으로 정렬되어 있다. 빈 배열은 허용되지만 널은 NullPonterException을 일으킨다. 무한대 값이 허용된다.

- **매개변수 :** `data`, 훑어볼 배열
이 메서드는 입력 배열에 포함된 값을 내림차순으로 정렬한 목록으로 반환한다. data가 널이면 NullPnterException을 던진다.

테스트는 다음과 같이 동작한다.

- 먼저 무작위 정수 목록을 생성한다. 목록에 반복된 숫자가 있는지 확인하기 위해 목록 크기를 100으로 하고 정수의 범위를 [0, 20]으로 제한한다.
- 그런 다음 unique 메서드를 호출하고, 결과로 받은 배열이 원래 배열의 모든 요소를 포함하고 있는지, 중복된 값은 없는지, 내림차순으로 정렬되어 있는지를 단언한다.

## 예제 3: indexOf 메서드 테스트

> `indexOf` 는 배열에서 지정된 인덱스로부터 시작하여 주어진 값이 위치하는 인덱스를 찾는다. 입력이 널이면 -1을 반환하고 startIndex가 음수이면 0으로 취급한다. 배열 길이보다 큰 startIndex는 -1을 반환한다.
> 

테스트의 전반적인 개념은 무작위 배열의 임의의 위치에 무작위 값을 삽입하는 것이다. indexOf 메서드는 이 무작위값을 찾는다. 그리고 요소를 삽입한 임의의 위치와 일치하는 인덱스를 반환한다.

이러한 테스트를 작성할 때 까다로운 부분은 배열에 추가하는 무작위값이 무작위 배열에 이미 존재하지 않는지 확인하는 일이다. 무작위로 생성된 배열 [1, 2, 3, 4]를 생각해볼 때 임의의 요소 숫자 4를 배열 인덱스 1에 삽입한다면 startIndex가 0이냐 3이냐에 따라 다른 응답을 얻게 된다. 이런 혼란을 피하려면 무작위로 생성된 배열에 존재하지 않는 임의의 값을 생성해야 한다. 속성 기반 테스트 프레임워크를 통해 이런 혼란을 쉽게 피할 수 있다.

## 예제 4: Basket 테스트

단순한 `remove` / `add` 테스트의 문제는 기능을 광범위하게 사용하지 않는 것이다. 장바구니에 물건을 추가하고 제거하는 길고도 예상하지 못한 과정을 거친 후에야 버그가 나타날 것이다. 

이 것을 속성으로 표현할 수 있다. 추가 및 제거 순서를 임의로 해도 장바구니의 합계는 여전히 정확히 계산된다. 

- 첫 번째 단계는 장바구니에서 발생할 수 있는 다양한 동작을 나타내는 액션을 만드는 것이다.
    - 액션은 복잡한 동작을 어떻게 실행할지 프레임워크에 설명하는 방법이다.
    - 현재의 경우, 제품을 장바구니에 추가하거나 장바구니에서 제품을 제거하는 두 가지 동작을 발생시킬 수 있다.

액션의 구현은 Action 인터페이스를 구현함으로써 만들어낼 수 있다.

- 물건 추가 액션의 경우, 추가 액션을 생성할 때마다 run 메서드에 장바구니를 넘기고 장바구니의 총가격 및 물건을 추가 및 합계를 단언하는 일련의 테스트 과정을 정의한다. 또한 현재 장바구니를 반환하여 다음 액션이 용이하도록 한다.
- 물건 제거 액션의 경우, 무작위로 물건을 골라서 제거하고 현재 합계가 장바구니에서 구한 총계에서 방금 제거한 물건 가격을 뺀 값과 같은지 확인한다.

속성 테스트는 이러한 액션들의 무작위 순서를 정의한 ActionSequence를 받는다. 

그 다음 무작위 제품을 생성하는 방법을 정의해야 한다. 제품 목록에서 Product를 무작위로 선택하게 하고, add() 메서드에 전달할 수량으로 임의의 정수를 생성한다. 이제 무작위 제품과 수량을 조합해서 만든 AddAction 인스턴스를 반환한다.

## 속성 기반 테스트의 일반적인 문제

### 1. 매우 비용이 많이 들거나 심지어 불가능한 데이터를 생성하도록 요구한다.

만약 2, 3, 5, 15의 배수인 무작위 정수 100개로 이루어진 배열을 생성하도록 요청하면, 무작위 접근 방식을 고려할 때 이러한 배열을 찾기 어려울 수 있다. 또는 10개의 고유한 요소가 있는 배열을 원하지만 2에서 8의 범위를 지정하면 배열을 생성할 수 없다. 
일반적으로 프레임워크가 데이터를 생성하는 데 시간이 너무 오래 걸리는 경우라면 다른 방법으로 테스트를 하는 게 낫다.

### 2. 버그는 경계에서 생기기 쉽다.

버그는 경계에서 생기기 쉽다는 것을 보았다. 따라서 우리는 속성 기반 테스트가 경계를 수행하기를 원한다. 속성의 경게를 올바로 나타내는지 확인하자. 5.1절의 합격 등급 문제에 대한 테스트를 작성할 때 Arbitraries.floats().lessThan(1f), Arbitraries.floats().greaterThan(10f)와 같이 임의로 값을 작성했다. jqwik은 경계값을 생성하기 위해 최선을 다한다. 예를 들어 가능한 가장 작은 실숫값이나 1f에 가장 가까운 숫자를 생성한다. jqwik의 기본 설정은 특이 케이스를 무작위 데이터와 혼합하도록 되어 있다. 다시 말하자면 이 모든 것은 속성과 경계를 올바르게 표현하는 경우에만 잘 작동한다.

- 속성 기반 테스트가 경계값을 적절히 포함하지 않으면, 중요한 버그를 놓칠 수 있음
- 개발자는 속성을 명확하게 정의해야 함
- 경계를 포함한 속성을 제대로 정의하지 않으면, 테스트가 비효율적으로 작동하거나 실제 중요한 결함을 찾지 못할 가능성이 있음

### 3. 테스트 대상 메서드에 전달한 입력 데이터가 가능한 모든 옵션 간에 균등하게 분포되어있는 지 확인해야 함

세 개의 int 값이 들어왔을 때 세 변이 삼각형을 이룰 수 있는지를 반환하는 메서드를 작성할 때, 무작위 정숫값을 만드는 속성 기반 테스트를 수행하면 유효한 삼각형 / 잘못된 삼각형 두 가지를 모두 표현할 가능성이 낮음. 유효한 삼각형은 무효한 삼각형에 비해 현저히 적을 것이다. 
잘 만들어진 속성 기반 테스트는 생성하는 유효, 무효 삼각형의 수가 같도록 한다.

## 창의성이 핵심이다

속성 기반 테스트를 작성하는 데는 창의성이 많이 필요하다. 속성이 나타내는 방법을 찾고, 임의의 데이터를 생성하고, 구체적인 입력을 모른 채로 예상 동작을 단언하는 일은 쉽지 않다. 속성 기반 테스트는 기존의 예시 기반 테스트보다 더 많은 연습이 필요하다.
