# Chapter 6. 테스트 더블과 모의 객체

- 이때까지는 클래스와 메서드를 분리해서 테스트하는 방식에 대해 학습함
    - 단일 메서드 호출에 입력을 전달하고 출력을 단언함
    - 클래스에 관해서는 클래스의 상태를 설정하고 테스트 대상 메서드를 호출한 후 클래스가 기대하는 상태로 있는지 단언함
- 하지만 어떤 클래스의 경우 작업을 수행할 때 다른 클래스에 의존함. 따라서 여러 클래스를 함께 수행하는 것이 바람직할 수 있음. 종종 복잡한 동작을 여러 클래스로 나누어 유지 보수성을 향상시키기 때문임. 
- 이 장에서는 종속성에 대해 너무 신경 쓰지 않고 격리된 방식으로 테스트를 하는 법에 대해 학습함. 왜 이런 테스트가 필요할까?
    - 테스트 대상 클래스를 구체적인 의존성과 함께 수행하는 일은 너무 느리거나, 너무 힘들거나, 너무 많은 일을 해야 할 수 있기 때문

- `IssuedInvoice` 클래스: 데이터베이스를 다루고 수많은 SQL 쿼리를 포함
    - (신규 송장을 생성하는 `InvoiceGenerationService` 클래스와 같이) 시스템의 다른 부분은 생성한 송장을 저장하는 작업을 IssuedInvocies 클래스에 의존함
    - 이는 곧 `InvocieGenerationService` 클래스를 테스트 할 때마다 이 클래스가 `IssuedInvoices` 클래스를 호출하고 데이터베이스와 통신을 해야함을 의미함
    - 이는 테스트하기에 많은 비용이 듬
    - `IssuedInvoices`에 있는 SQL 쿼리가 올바른지는 테스트하고 싶지 않고, 송장이 올바르게 생성되었거나 값이 모두 제대로 포함되어 있는지만 확인하고 싶을 수 있음

- **테스트 더블**을 통해 다른 클래스에 의존하는 클래스를 테스트할 때 의존성을 사용하지 않을 수 있음. 구성요소 B의 동작을 모방하는 객체를 생성하는 것임. 다른 객체의 동작을 시뮬레이션하는 객체를 사용하면 다음과 같은 장점을 가질 수 있다.
    - **더 큰 제어권을 가진다.**
    - **시뮬레이션은 빠르다.**
    - 모의 객체를 설계 기법으로 하여 **클래스 간의 상호작용을 반영할 수 있다.**

## 6.1 더미, 페이크, 스텁, 모의 객체, 스파이

### 6.1.1 더미 객체
더미는 테스트 대상 클래스에 전달되지만 절대 사용되지 않는 객체다. 

### 6.1.2 페이크 객체
페이크 객체는 시뮬레이션하려는 클래스같이 실제로 동작하는 구현체를 가진다. 대개 똑같이 동작하는 것은 아니고 훨씬 단순한 방법으로 동작한다. 

### 6.1.3 스텁
스텁은 테스트 과정에서 수행된 호출에 대해 하드 코딩된 응답을 제공한다. 페이크 객체와는 달리 스텁은 실제로 동작하는 구현체가 없다. 

### 6.1.4 모의 객체
모의 객체는 메서드의 응답을 설정할 수 있다는 점에서 스텁 같은 역할을 한다. 하지만 모의 객체는 그 이상이다. 모의 객체는 모든 상호작용을 저장해서 나중에 단언문에 활용할 수 있도록 한다. 메서드가 몇 번 호출 되었는 지를 테스트하는 단언문을 작성할 수 있다. 

### 6.1.5 스파이
이름에서 알 수 있듯이 스파이는 의존성을 감시한다. 스파이는 실제 객체를 감싸서 그 행동을 관찰한다. 엄밀히 말해 객체를 시뮬레이션하는 게 아니라 감시하고 있는 근본 객체와의 모든 상호작용을 기록한다.
스파이는 특정 맥락에서 사용된다. 모의 객체를 사용하는 것보다 실제로 구현하는 게 훨씬 쉽고, 테스트 대상 메서드가 의존 대상과 어떻게 상호작용하는지 단언하고자 하는 경우에 사용한다. 스파이는 현업에서는 보기 힘들다.

## 6.2 모의 객체 프레임워크

### 6.2.1 의존성 스텁화

모키토의 `when()` 메서드를 이용해서 목록을 반환하도록 한다. 테스트 대상 메서드에서는 `when()`에 정의된 메서드를 호출하면 스텁을 반환한다. 스텁을 적용함으로써 테스트 대상이 아닌 클래스로 인한 실패를 방지할 수 있다.

### 6.2.2 모의 객체와 기댓값

> 작은 값을 가진 송장을 모두 SAP 시스템으로 전송해야 한다. SAP는 송장을 받기 위해 SendInvoice 웹 서비스를 제공한다.

실제 전체 SAP 웹 서비스에 의존하지 않고 새로운 클래스를 테스트하고 싶을 것이다. SAP 인터페이스가 있다고 가정한다. `InvocieFilter` 클래스를 이용해서 작은 값의 송장을 모두 얻은 다음 SAP에 그 결과를 전송한다.

`InvoiceFilter`를 테스트하는 것이 목표가 아니므로, 이 클래스를 스텁으로 만들어서 테스트하련느 메서드를 테스트해야 한다. 스텁은 작은 값을 가진 송장 목록을 반환한다.

이 테스트의 주목적은 작은 값의 송장이 모두 SAP에 전송되는지 확인하는 것이다. 진짜 SAP 없이 어떻게 이 동작이 일어난다고 단언할 수 있을까? 이는 간단하다. SAP에 있는 send() 메서드 호출이 발생했는지 확인하면 된다. 그건 어떻게 확인할 수 있을까?

모키토는 뒤에서 모의 객체와의 상호작용을 모두 기록한다. SAP 인터페이스를 모의해서 테스트 대상 클래스에 전달하고, 테스트 마지막에 우리가 할 일은 해당 메서드가 호출되었는지 모의 객체에 물어보는 일뿐이다. 이를 위해 모키토의 verify 단언문을 사용한다. 

**이 예제는 스텁과 모의의 중요한 차이점을 보여준다**. 스텁은 어떤 메서드 호출에 대해 하드 코딩한 값을 반환한다. 모의는 훨씬 더 구체적인 기댓값을 정의할 수 있게 해준다. 

### 6.2.3 인수 포획

> SAP는 이제 Invoice 엔티티를 직접 받는 대신 다른 형식으로 전송된 데이터를 받는다. SAP는 고객명, 송장 가격, 생성 ID가 필요하다.
> ID는 다음과 같은 형식을 따른다: <날짜><고객 코드>
> - 날짜는 항상 `MMddyyyy` 형식이어야 한다: <월><일><4자리 년도>
> - 고객 코드는 고객 이름의 첫 두 글자다. 고객 이름이 두 글자보다 짧으면 'X'로 한다.

SAP 인터페이스를 바꿔서 `SapInvoice` 엔티티를 받을 수 있도록 구현한다. 이 엔티티는 customer, value, id 세 개의 필드를 가진다. 그런 다음 `SAPInvoiceSender`를 수정해서 낮은 가격의 송장에 대해 적당한 id를 가진 `SapInvoice` 엔티티를 생성하고 SAP에 전송하도록 한다.

테스트를 하려면 `InvoiceFilter` 클래스를 스텁으로 만들어야 한다. 또한 SAP 클래스를 모의해서 `send()` 메서드가 호출되었는지 확인할 수 있다. 하지만 생성된 `SapInvoice`가 올바른 것인지 어떻게 단언할 수 있을까?

`Invoice`를 `SapInvoice`로 변경하는 로직을 추출하고 이를 모키토의 또 다른 기능인 인수 포획기를 통해 객체를 얻어오면 된다.

코드를 리팩토링해서 간단한 단위 테스트를 작성할 수 있는 방법도 좋지만 인수 포획기도 종종 사용된다.

### 6.2.4 예외 시뮬레이션
> 시스템은 전송에 실패한 송장 목록을 반환해야 한다. 실패가 일어나더라도 프로그램이 멈추면 안 된다. 그 대신 프로그램은 몇몇 송장에 전송 실패가 일어나더라도 모든 송장을 보내려고 시도해야 한다.

`doThrow().when()`와 같이 모키토의 기능을 잇달아 호출하면 된다. 이 방법은 `when()`과 유사하지만 예외를 던진다. 모의 객체가 예외를 던지도록 구성하면 시스템이 예상하지 못한 시나리오에서 어떻게 동작할지에 대해 테스트할 수 있다. 이 방법은 외부 시스템과 상호작용하면서 기대한 대로 동작하지 않을 수 있는 많은 소프트웨어 시스템에 적합하다. 

## 6.3 현업에서의 모의 객체

언제 모의 객체를 사용하고, 언제 사용하지 말아야 할까? 또 따라 할 만한 다른 모범 사례가 있는가?

### 6.3.1 모의 객체의 단점

어떤 개발자는 모의 객체를 사용하는 것은 테스트 스위트가 **코드가 아니라 모의 객체를 테스트**하도록 한다고 말한다. 실제로 모의 객체를 사용하면 자연스럽게 테스트를 덜 현실적으로 만든다. 상용 버전에서는 구현체를 사용하는데, 클래스를 모의했기 때문에 구현체의 통신 방식을 놓칠 수 있다. 대규모 소프트웨어에서는 모의 객체가 클래스의 실제 계약을 표현하지 않을 수 있다는 점에서 모의 객체에 대한 제어권을 잃기 쉽다.

또 다른 단점으로, 모의 객체를 사용한 테스트는 자연스럽게 모의 객체를 사용하지 않는 테스트보다 코드와 결합하게 된다. 모든 테스트를 모의 객체를 사용하지 않고 작성했다고 생각해보자. 테스트는 어떤 메서드를 호출해서 결과를 단언한다. 메서드의 실제 구현에 대해서는 아무것도 모른다. 모의 객체의 경우 테스트 대상 클래스에 대한 정보를 너무 많이 안다. 이렇게 테스트가 많은 것을 알게 되면, 테스트를 변경하기 힘들 수 있다. 

### 6.3.2 모의해야 하는 대상과 하지 말아야 하는 대상

모의 객체와 스텁은 단위 테스트 작성 과정을 단순하게 하기 위한 유용한 도구이지만, **지나친 모의** 역시 문제가 될 수 있다. 진짜 의존성을 사용하는 테스트는 테스트 더블을 사용하는 테스트보다 더 실질적이다. 결론적으로 실제 버그를 더 찾기 쉽다. 따라서 모의해서는 안 되는 의존성은 모의하지 않아야 한다.

실용적으로 의존성이 다음과 같은 종류일 때 모의 객체나 스텁을 사용한다.

- **의존성이 너무 느린 경우**: 어떤 이유에서든 의존하는 대상이 너무 느리다면 이를 시뮬레이션하는 것은 좋은 생각이다. 우리는 느린 테스트 스위트를 원하지 않는다. 따라서 데이터베이스나 웹 서비스를 다루는 클래스를 모의하면 좋다. 이런 클래스가 올바로 동작하는지 확인하기 위해 여전히 통합 테스트를 작성하지만, 느린 클래스에 의존하는 클래스를 테스트하는 경우 모의 객체를 사용한다.
- **의존성이 외부 인프라와 통신하는 경우**: 의존성이 외부 인프라와 통신하고 있다면 이 동작은 매우 느리거나 인프라를 설정하는 과정이 복잡할 수 있다.
- **의존성을 시뮬레이션하기 힘든 경우**: 의존성을 강제로 시뮬레이션하기 힘든 경우 모의 객체나 스텁이 도움이 된다. 흔히 볼 수 있는 예가 의존성이 예외를 던지도록 하고 싶을 때다.

반면 다음과 같은 경우에서는 모의 객체나 스텁을 꺼리게 된다.

- **엔티티**: 엔티티는 비즈니스의 개념을 표현하는 클래스다. 엔티티는 다루기 간단한 클래스이므로, 모의하는 데 공수가 더 많이 든다.
- **네이티브 라이브러리와 유틸리티 메서드**: 프로그래밍 언어에 있는 라이브러리나 유틸리티 메서드를 모의하거나 스텁으로 만드는 일 또한 일반적이지 않다.
- **충분히 단순한 의존성**

### 6.3.3 날짜 및 시간 래퍼

날짜 및 시간 연산은 흔하게 일어나기 때문에 전용 클래스로 감싸는 게 좋다.

> 프로그램은 만약 현재 날짜가 크리스마스라면 총 주문 금액의 15%를 할인한다. 다른 날짜에 대해서는 할인하지 않는다.

크리스마스/크리스마스가 아닌 날을 테스트하려면 `LocalDate` 클래스를 제어/스텁화해서 원하는 날짜를 반환하도록 해야 한다. 이 메서드가 `LocalDate.now()`를 직접 호출하기 때문에 지금은 쉬운 일이 아니다.

어떻게 시간 API를 스텁으로 만들 수 있을까? 어떻게 해야 `LocalData.now()`를 호출하는 정적 메서드를 스텁으로 만들 수 있을까? 모키토는 정적 메서드를 모의할 수 있는 기능이 있다. 

다른 해결책은 모든 날짜 및 시간 로직을 어떤 클래스로 캡슐화하는 방법이다. Clock이라는 클래스를 만들어서 이 클래스가 해당 연산을 수행하도록 한다. 시스템의 다른 요소는 날짜와 시간을 다룰 때 이 클래스만 사용한다. 새로 만든 Clock은 필요한 모든 클래스에 의존성으로 전달되고 따라서 스텁으로 만들 수 있다.

### 6.3.4 소유하지 않은 것을 모의하기

모의할 때 모범 사례는, 소유하지 않은 것은 모의하지 말라는 것이다. 소프트웨어 시스템이 어떤 라이브러리를 사용한다고 할 때, 이 라이브러리는 비용이 비싸기 때문에 100% 모의하기로 결정하면 다음과 같은 문제가 발생할 수 있다.

- 라이브러리 변경이 발생해도 테스트는 깨지지 않는다. 전체 동작을 모의했기 때문이다. 
- 모든 API 호출을 모의하는 일은 너무 복잡하다. 테스트는 머지않아 유지 보수하기 어렵게 될 것이다.

### 6.3.5 모의에 관한 외부 의견

- **테스트 더블을 사용하려면 시스템이 테스트 가능성을 가지도록 설계해야 한다.** 모의 객체를 사용하면 테스트 대상 클래스가 모의 객체를 받을 수 있는지 확인해야 한다.
- **실제 구현에 충실하게 테스트 더블을 구축하는 일은 어렵다. 하지만 가능한 한 그렇게 해야 한다.** 만약 모의 객체가 제품 코드의 계약과 기댓값을 동일하게 가지지 않으면 테스트는 전부 통과하지만 배포 버전에서 실패하게 될 것이다. 모의를 할 때 모의 객체가 모의하는 클래스를 충분히 표현하고 있는지 확인하자.
- **고립성보다 현실성이 낫다. 가능하다면 페이크나 스텁, 모의 객체보다 실제 구현을 선택하도록 하자.** 현실성은 항상 고립성을 이긴다.
- 테스트 더블의 사용 여부를 결정할 때 고려할 사항이다.
    - **실제 구현의 수행 시간**
    - **실제 구현을 사용하면 얼마나 비결정적이 되는가**
- **실제 구현을 사용하는 일이 불가능하거나 너무 비용이 많이 든다면 모의 객체보다 페이크를 사용한다.** 
완전히 동의하지는 않는다. 이 경우에는 실제 구현을 사용하거나 모의를 해야 한다. 페이크가 실제 구현과 동일하게 동작하는지 어떻게 확인할 수 있을까?
- **모의를 너무 많이 사용하면 위험해질 수 있다. 테스트가 불분명해지고(이해하기 어려움), 깨지기 쉽고(너무 자주 꺠질 수 있음), 덜 효과적이기(결함 탐지 능력이 감소됨) 때문이다.**
- **모의할 때는 상호작용 테스트보다 상태 테스트가 낫다.** 
- **너무 구체화된 상호작용 테스트는 피하자. 인수 및 기능 테스트에 초점을 두자.** 
- **좋은 상호작용 테스트를 작성하려면 테스트 대상 시스템을 설계할 때 엄격한 지침이 필요하다.**