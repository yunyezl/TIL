# Chapter 4. 계약 설계

> 이 장은 다음과 같은 내용을 다룬다.
>
> - 사전 조건, 사후 조건, 불변식을 설계하는 방법
> - 계약과 유효성 검사의 차이점에 대한 이해
>

소프트웨어 시스템은 복잡한 정보 흐름 속에서 커다란 루틴을 실행하기 위해 여러 하위 루틴(또는 클래스)를 연속적으로 호출한다. 특정 클래스가 수행하는 계산은 입력 값이 양수일 때만 가능하다는 요구사항이 있다면, 이런 제약사항을 어떻게 모델링하고 싶은지 생각해 볼 필요가 있다. 다음과 같은 선택지가 있다.

- 클래스가 유효하지 않은 입력으로 다른 클래스를 절대로 호출하지 못하도록 한다. 이 방법은 테스트 대상 클래스의 코드를 단순하게 만들어준다. 특이 케이스를 다룰 필요가 없기 때문이다. 이렇게 하면 호출하는 클래스에 복잡성이 추가된다.
- 프로그램을 방어적으로 작성하는 방법이 있다. 만약 유효하지 않은 입력이 발생하면 시스템은 중단되고 사용자에게 에러 메시지를 전달한다. 이 방법은 시스템에 있는 모든 클래스의 복잡성을 약간 증가시킨다. 클래스가 유효하지 않은 입력을 어떻게 다루어야 하는지 알아야 하기 때문이다. 이 방법은 시스템을 탄력적으로 만든다. 하지만 임시방편으로 방어 코드를 만드는 일은 생산적이지 않다. 결국은 이미 확인했던 제약사항을 다시 확인하는 것처럼 불필요한 코드를 추가해야 한다.
- 개발 중인 각 클래스에 대해 명확한 계약을 정의한다. 이는 이 책의 목표이기도 하다. 꼐약은 클래스가 *사전 조건으로 무엇을 요구*하는지, 클래스는 *사후 조건으로 무엇을 제공*하는지, *불변식은 클래스에 대해 항상 무엇을 유지하도록 하는지*를 명확하게 설립한다.

## 사전 조건과 사후 조건

세금 계산 예제에서 메서드가 제대로 동작하도록 하는. **사전 조건**과 메서드가 산출물로 보장하는 **사후 조건**을 고찰할 필요가 있다. 앞서 메서드는 사전 조건으로 음수를 받을 수 **없다**고 언급했다. 이 메서드에 대해 가능한 사후 조건 역시 음수를 반환하지 않는 것이다.

사전 조건과 사후 조건은 서로 다른 내용을 보장한다. (이 경우에서 단 하나 뿐인) 사전 조건은 메서드가 받아들인 입력값이 요구사항을 준수하도록 보장한다. 사후 조건은 메서드가 다른 메서드에 약속한 것을 반환하도록 보장한다.

문서에 사전, 사후 조건을 명확히 기술하는 일 역시 중요하고 매우 권장된다. 주석을 활용하여  param에 사전 조건을 명시하는 것이 좋다.

### 강한 조건과 약한 조건

사전, 사후 조건을 정의할 때 중요한 점은 조건의 강도를 어느 정도로 해야 하는지다. 앞의 예에서는 사전 조건을 매우 강하게 다루었다. (`assert` 사용)
음수일 때 프로그램을 중지하지 않으려면 사전 조건을 약화시키면 된다. 즉 0보다 큰 값만 받는 대신 메서드가 양수나 음수 어떤 값도 받을 수 있도록 하는 것이다.

약한 사전 조건은 다른 클래스가 이 메서드를 쉽게 호출할 수 있도록 한다. 약한 것을 쓸지 강한 것을 쓸 지에 대한 정답은 없다. 그것은 개발하는 시스템의 종류에 따라 다르고, 모델링하고 있는 클래스의 소비자에게서 기대하는 바가 무엇인지에 따라 다르다.

> **같은 이유를 사후 조건에도 적용할 수 있을까?**
> 예외를 던지는 대신 값을 반환해야 할 이유를 찾을 수도 있다. 그러나 그럴 필요는 대체로 없다. 구현에 버그가 있다는 뜻이기 때문이다.

어떨 때는 약한 사전 조건을 쓸 수 없는 경우가 있다. 세금 계산기는 음수를 받을 수 없고 사전 조건은 강해야 한다. 이런 경우를 다루는 또 다른 방법으로 에러값을 반환하는 방법이 있다. 예를 들어 음수가 들어왔을 때 프로그램을 중단하는 대신 0을 반환하도록 할 수 있다. 

## 불변식

불변식이란 메서드의 사전, 사후 **모두의** 경우에서 유지되어야 하는 조건이다. 따라서 불변식은 어떤 객체나 데이터의 생명 주기 전체에 해당하는 조건을 가진다.

```java
public class Basket {
    private BigDecimal totalValue = BigDecimal.ZERO;
    private Map<Product, Integer> basket = new HashMap<>();

    public void add(Product product, int qtyToAdd) {

    }

    public void remove(Product product) {
        
    }
}

```

위 코드의 add 메서드에 대해서는 다음과 같은 사전 / 사후 조건을 생각할 수 있다.

- 제품이 널이 아님을 보장하는 사전 조건
- 추가할 수량이 0보다 큼을 보장하는 사전 조건
- 제품이 장바구니에 추가되었음을 보장하는 사후 조건
- 새로운 합계는 이전 합계보다 커야 한다는 사후 조건

remove 메서드에 대한 사전 조건은 다음과 같이 생각할 수 있다.

- 사전 조건: 제품이 널이면 안된다. 또한 장바구니에 있어야한다.
- 사후 조건: 제품이 더 이상 장바구니에 있으면 안된다.

여기서 클래스 불변식을 모델링 할 수 있다. 장바구니에 더하거나 뺄 제품과는 상관없이 장바구니에 있는 제품의 합계는 절대 음수가 될 수 없다. 이는 사전 조건도, 사후 조건도 아닌 **불변식**이다.

## 계약 변경과 리스코프 치환 법칙

변경으로 인한 영향을 파악하는 가장 쉬운 방법은 변경 그 자체를 살펴보거나 변경이 일어난 클래스를 확인하는 것이 아니라, 변경된 클래스를 사용하는 다른 모든 클래스를 살펴보는 것이다.  
어떤 대상에 대해 사전 조건을 약화시키거나 덜 제한하면 변경된 클래스는 클라이언트와 맺은 계약을 깨뜨리지 않는다.  
반면 사후 조건 어떤 대상에 대해 사후 조건을 약화하거나 덜 제한하면 클라이언트가 망가진다.

### 상속과 계약

- 자식 클래스 S의 사전 조건은 부모 클래스 B의 사전 조건과 같거나 약해야 한다. (더 많은 값을 받아야 함)
- 자식 클래스 S의 사후 조건은 부모 클래스 B의 사후 조건과 같거나 강해야 한다. (더 적은 값을 반환해야 함)

시스템에 기대하는 동작을 깨뜨리지 않고 자식 클래스를 부모 클래스로 치환할 수 있는 개념을 리스코프 치환 법칙이라고 한다.

## 계약에 의한 설계와 테스트 간의 연관성

사전 조건, 사후 조건, 불변식을 정의하면 개발자에게 많은 도움이 된다.

1. 단언문을 통해 제품 코드에서 버그를 일찍이 발견할 수 있다.
2. 사전 조건, 사후 조건, 불변식은 개발자에게 테스트 대상을 제공한다.
우리는 qty > 0인 사전 조건을 보자마자 이것이 단위 테스트, 통합 테스트 또는 시스템 테스트로 실행할 대상이라는 것을 안다. 따라서 계약은 (단위) 테스트를 대체하지 않는다. 즉, 보강한다.
3. 명시적 계약은 소비자의 삶을 편안하게 해준다.

## 현업에서의 계약에 의한 설계

### 강한 사전 조건 vs 약한 사전 조건

계약을 모델링할 때 매우 중요한 의사결정사항은 계약을 강하게 할지 약하게 할지다. 이는 트레이드오프의 문제이다.  
약한 사전 조건을 가진 메서드는 클라이언트가 사용하기 편하지만, 이는 메서드에 유효하지 않은 입력을 다루도록 추가 부담을 준다.  
반대로 강한 계약의 경우, 추가 부담은 클라이언트 측에 있다.  

명확한 방법은 없다. 전체 맥락을 고려해서 결정해야 한다.

### 입력 유효성 검사인가? 계약인가? 아니면 둘 다인가?

**유효성 검사**와 **계약**간의 차이는 다음과 같다.

- **유효성 검사**는 사용자로부터 들어올 수 있는 불량 데이터나 유효하지 않은 데이터가 시스템에 침투하지 않도록 한다.
- **계약**은 클래스 간의 의사소통이 문제없이 일어나도록 한다. 계약 위반이 일어나면 프로그램은 중지한다.

이처럼 유효성 검사와 계약은 다르기 때문에 둘 다 이루어져야 한다.

### 단언과 예외: 둘 중 하나를 사용해야 하는 경우

- 라이브러리나 유틸리티 클래스에 대한 계약을 모델링할 경우, 유명한 라이브러리를 사용하였을 때는 이를 신뢰하고 예외를 선호한다.
- 비즈니스 클래스와 클래스 간의 계약을 모델링하고 있고 데이터가 이전 레이어에서 정제되었다는 것을 알고 있다면, 단언문을 선호한다.
- 비즈니스 클래스를 모델링하지만 데이터가 이미 정제되어있는지 모를 경우, 예외를 선택한다.
