# Chapter 3. 구조적 테스트와 코드 커버리지

명세 기반 테스트가 완료되면 다음 단계는 **소스 코드를 활용해서 테스트 스위트를 확장**하는 것이다. 이를 구조적 테스트라고 한다.
구조적 테스트를 해야하는 이유는 다음과 같다.
1. 요구사항을 분석할 때 한두 개 구획을 빼먹어도 소스 코드를 보는 동안 알아차릴 수 있다.
2. 문서에 명시되어 있지 않은 언어 구조, 알고리즘 및 데이터 구조를 활용한다.

## 3.1 코드 커버리지, 올바른 방법
- 요구사항: 주어진 문장에서 's' 또는 'r'로 끝나는 단어의 수를 세어야 함
	* 문자열에 있는 각 문자에 대해 반복
	* 현재 문자가 글자가 아니고 이전 문자가 's'나 'r'이면 단어를 찾은 것
	* 현재 문자를 last 변수에 저장
	* 문자열이 r이나 s로 끝나면 개수를 증가시킴
* 이에 대해 다음과 같이 테스트를 작성
	* 's'로 끝나는 두 단어의 경우 프로그램이 2를 반환하기를 기대
	* 문자열에 's'나 'r'로 끝나는 단어가 없는 경우 프로그램이 0을 반환하기를 기대
위의 테스트 케이스는 여전히 매우 부족하고 코드 커버리지 도구를 활용하여 분기가 일어날 수 있는 케이스에 대하여 추가적인 테스트 코드를 추가할 수 있다.

## 3.2 구조적 테스트 간략히 살펴보기
1. 명세 기반 테스트를 수행한다.
2. 구현사항을 읽고, 개발자의 주요 결정사항을 이해한다.
3. 고안했던 테스트 케이스를 코드 커버리지 도구로 수행한다.
4. 테스트가 수행되지 **않은** 코드에 대해
	a. 왜 그 코드가 수행되지 않았는지 **이해한다.** 명세 테스트 도중에 왜 발견하지 못했을까?
	b. 그 코드가 테스트할 가치가 있는지 **결정한다.** 
	c. 테스트가 필요하다고 판단할 경우 놓친 코드 조각을 수행하는 **자동화된 테스트를 구현한다.**
5. 소스 코드를 바탕으로 **고안할 만한 다른 흥미로운 테스트가 있는지 찾아본다.**

이 접근법은 결국 **구조적 테스트는 이전의 명세 기반 테스트로 고안한 테스트 스위트를 보강한다**는 것

## 3.3 코드 커버리지 기준
```
if (!Character.isLetter(str.charAt(i)) && (last == 's' || last == 'r'))
```

어떤 개발자는 해당 줄을 **수행**만 하도록 결정할 수 있고, 다른 개발자는 if문이 `true`또는 `false`로 평가되는 경우를 수행하도록 할 수 있다.
또한 if문 내 두 조건을 모두 찾아내고자 할 수도 있다. 이런 케이스들 모두 종합하면 8개의 테스트가 필요한데, 이를 공식화 할 수 있다.

### 3.3.1 코드 줄 커버리지
- 코드 줄 커버리지를 달성하고자 하는 개발자는 해당하는 줄이 단순 실행이 된 경우 해당 줄을 수행했다고 계산할 수 있다.

### 3.3.2 분기 커버리지
- 분기 지시문이 어떻게 평가되는지에 따라 프로그램이 다르게 동작한다는 점을 고려함

### 3.3.3 조건 + 분기 커버리지
- 분기뿐만 아니라 분기문의 각 조건도 고려함. 여러 조건이 있는 if 문이 단순 전체 true가 되는 경우 뿐만 아니라, 각 조건들을 각각 개별로 만족 / 만족하지 않는 케이스를 고려

### 3.3.4 경로 커버리지
- 프로그램이 수행할 수 있는 **모든** 실행 경로를 수행함
- 달성하기가 종종 불가능하거나 너무 비용이 많이 든다.

## 3.4 복잡한 조건과 MC/DC 커버리지 기준
테스트 스위트를 구축하기 위한 노력과 비용을 최소화하면서 찾아낼 수 있는 버그 수를 최대화하려면 `수정된 조건/의사결정 커버리지`를 적용하는 것이 좋다.
그러나 앞선 장에도 언급햇듯, 가능한 **모든** 조합을 테스트하는 대신 필요한 **중요한** 조합을 찾아낸다. 
- MC/DC는 각 조건을 수행하되 이 조건이 다른 조건과는 상관없이 전체 의사결정 결과에 영향을 미칠 수 있도록 한다.
- 각 매개변수의 가능한 모든 조건은 적어도 한 번은 결과에 영향을 주어야 한다.

### 3.4.1 추상적인 예제
```
if (A && (B || C))
```
여기서 A, B, C는 모두 불리언으로 평가된다. MC/DC는 다음과 같이 기술할 수 있다.
- **A의 조건에 대해**
	* A = true인 경우에 대해 테스트 케이스가 하나 있어야 한다. (T1)
	* A = false인 경우에 대해 테스트 케이스가 하나 있어야 한다. (T2)
	* (**독립 쌍**이라고 부르는) T1과 T2는 서로 다른 결과를 내야한다. (T1의 전체 의사 결정이 true로 평가된다면 T2는 false로 평가되어야 한다.)
	* T1의 변수 B, C는 T2의 B, C에 대해 동등해야 한다. (둘 다 true이거나 둘 다 false로 평가한다.)
* **B의 조건에 대해**
	* B = true인 경우에 대해 테스트 케이스가 하나 있어야 한다. (T3)
	* B = false인 경우에 대해 테스트 케이스가 하나 있어야 한다. (T4)
	* T3와 T4는 서로 다른 결과를 내야 한다.
	* T3의 변수 A, C는 T4의 A, C와 동등하다.
* **C의 조건에 대해**
	* C = true인 경우에 대해 테스트 케이스가 하나 있어야 한다. (T5)
	* C = false인 경우에 대해 테스트 케이스가 하나 있어야 한다. (T6)
	* T5와 T6는 서로 다른 결과를 내야 한다.
	* T5의 변수 A, B는 T6의 A, B와 동등하다.

조건이 이진 결과(즉 true 또는 false)만 있는 경우 MC/DC 커버리지를 100% 달성하는 데 필요한 테스트의 개수는 N + 1이다. 
이렇게 조합한 테스트 케이스는 다른 조건을 독립적으로 조합한 경우를 모두 수행한다.

### 3.4.2 MC/DC를 달성하는 테스트 스위트 작성하기
이전의 예시에서 (1) 현재 문자가 글자인지 여부와 (2) 이 글자가 `s` 또는 (3) `r` 인지의 여부가 추상적인 예시에서 논의한 A && (B || C) 예시와 같음
전체 조합의 경우 2의 3승으로 총 8개이지만, 우리는 MC/DC 전략에 따라 총 4개의 테스트를 선택할 수 있음
여러 변수를 커버할 수 있는 테스트 케이스를 찾고 이를 적용하는 것이 효율적인 전략

## 3.5 반복문과 유사 구조 처리하기
반복문의 경우, 알 수 없는 횟수만큼 반복되므로 완벽한 테스트는 불가능하다. 때문에 종종 **반복 경계 적합 기준**을 적용하여 언제 반복 테스트를 중지할 지 결정한다.
- 반복문을 0번 수행하는 테스트 케이스
- 반복문을 1번 수행하는 테스트 케이스
- 반복문을 여러 번 수행하는 테스트 케이스

반복문을 여러 번 실행하는 테스트 케이스를 고안하는 경우가 가장 어려운데, 명세를 충분히 이해하고 `여러 번`의 경우에 대해 테스트를 두 개 이상 만드는 것을 두려워하지 말 것

## 3.6 기준 포함과 선택
- 일부 전략은 다른 전략을 **포함**한다. 전략 Y가 수행하는 모든 요소를 전략 X도 수행한다면 X는 Y를 포함한다.
- 분기 커버리지는 코드 줄 커버리지를 포함하고, 그 반대는 성립되지 않는다.
- 조건 + 분기 커버리지는 항상 모든 분기 커버리지와 코드 줄 커버리지를 의미한다.
- 일련의 사고에 따라 경로 커버리지는 모든 다른 기준을 포함한다.
- MC/DC는 조건 + 분기 커버리지보다 더 탄탄하다. MC/DC가 각 조건의 독립성을 보장하기 때문이다.

즉, 어떤 기준 대신 다른 기준을 선택할 때 트레이드 오프가 필요하다. 취약한 기준은 비용이 적고 빠르게 수행할 수 있지만 코드가 수행하지 않는 부분을 많이 남기게 된다.
반면에 탄탄한 기준은 비용을 많이 들여서 더 엄격하게 코드를 수행할 수 있다.

## 3.7 명세 기반 테스트와 구조적 테스트: 실제 사례
> 입력 문자열이 "abc"이고 덧붙일 문자열이 "-", size가 5인 경우 프로그램의 결과는 "--abc"가 되는 `leftPad()`함수
- str: 주어진 문자열, null이 될 수 있음
- size: 합친 문자열의 크기
- padStr: 덧붙일 문자열로 널 또는 빈 문자열은 공백 한 칸으로 취급

이에 대해 다음과 같은 프로세스로 테스트를 진행할 수 있다.
1. 요구사항을 읽는다. 프로그램은 문자열이 특정 크기가 될 때까지 문자열의 시작에 주어진 문자/문자열을 추가한다는 것을 이해한다.
2. 1단계에서 관찰한 내용을 바탕으로 구획을 도출한다. *(명세 기반 테스트)*
3. 경계를 도출한다.
4. 널 문자열, 빈 문자열, 음의 크기와 같은 예외적인 경우에 대해 하나의 테스트만 고안해도 된다.
이제 구조적 테스트를 통해 테스트 스위트를 강화할 수 있다. 커버리지 도구를 이용해서 이미 수행한 부분을 찾아보면, 보고서는 몇몇 분기가 누락되었음을 알려준다.

## 3.8 경계 테스트와 구조적 테스트
접점 및 거점을 찾아내고 테스트를 수행하는 개념은 구조적 테스트에 잘 들어맞는다. 
- `if (pad <= 0)`: 접점은 0이며, 표현식을 true로 평가하는 점이다. 거점은 접점에 가장 가까우면서 표현식을 `false` 평가하는 점이다.
* `if (pads == padLen)`: 접점은 padLen이 된다. 등식이 주어졌고 padLen이 정수형이므로 거점은 두 개가 된다. 하나는 pads == padLen - 1일 때이고 다른 하나는 pads = padLen + 1일 때이다.
* `if (pad < padLen)`: 접점은 padLen - 1이 된다. 거점은 식을 false로 평가하는 점이다. 따라서 거점은 padLen이 된다.

## 3.9 구조적 테스트만 적용하는 것은 충분하지 않다.
입력값이 들어올 경우, 덩어리의 갯수를 세는 프로그램 (ex. aaabbbccc -> 3)
- nums: 덩어리를 세기 위한 배열로, 널이여서는 안 되고 길이가 0보다 커야함. 프로그램은 사전 조건을 위반하면 0을 반환한다.
1. 널이거나 빈 문자열이면 즉시 0을 반환
2. 현재 숫자가 이전 숫자와 같으면 덩어리로 판단
3. 현재 숫자가 이전 숫자와 다르면 덩어리가 아님


> 빈 배열인 경우 / 배열이 널인 경우 / 중간 세 개의 요소가 한 덩어리를 이루는 배열인 경우 / 요소가 하나만 있는 배열

위 네 개의 케이스로 분기 커버리지를 100% 달성하지만, 흥미로운 테스트 케이스를 많이 빼먹었다. 
배열의 마지막 항목이 최종 덩어리가 되도록 하거나 첫 번째 위치에서 덩어리가 시작되도록 하는 배열을 사용해볼 수 있었다. 
