# Chapter 7. 테스트 가능성을 위한 설계

**테스트 가능성**은 테스트 대상 시스템이나 클래스, 메서드에 대해 자동 테스트를 얼마나 쉽게 작성할 수 있는지를 말한다. 6장에서 우리는 테스트 대상에 의존성을 주입할 수 있도록 변경하여 의존성을 스텁으로 받을 수 있었다. 이 장은 쉽게 테스트할 수 있도록 도와주는 새로운 전략에 대해 설명한다.

테스트 가능성을 위한 설계는 체계적인 테스트를 수행하기 위한 핵심사항이다. 코드가 테스트하기 어려우면 테스트를 하지 않으려고 할 것이다. 테스트 가능성을 위한 설계는 언제 진행해야 할까? 테스트 가능성을 생각해야 하는 적당한 때는 언제인가? **항상 고려해야 한다.** 이는 어떤 기능을 구현하는 내내 발생하는 일이다.

테스트 가능성을 처음부터 설계해야 한다. 때로는 구현 과정에서 테스트가 불가능한 부분을 확인하지 못할 때가 있다. 그리고 테스트 단계에서 깜짝 놀라곤 한다. 이런 일이 일어나면 코드를 다시 리팩토링한다.

테스트 가능성을 위한 설계는 어렵고 추가적인 코드를 너무 많이 작성해야 한다고 주장하는 개발자가 있는데, 이는 사실이다. 스파게티 코드를 작성하는 일은 상호협력적이고 응집력이 있으며 테스트하기 쉬운 클래스를 개발하는 일보다 쉽다. 다만 **테스트 가능성을 위한 설계가 노력을 들일 만한 가치가 있다는 것을 알아야 한다.**

## 7.1 도메인 코드에서 인프라 코드를 분리하기

가장 중요한 원칙은 **도메인 코드에서 인프라 코드를 분리하는 것**이다.

**도메인**은 시스템의 핵심이 있는 곳이다. 즉 모든 비즈니스 규칙, 로직, 엔티티, 서비스 및 이와 유사한 서비스를 들 수 있다. **인프라스트럭처**는 외부 의존성을 다루는 코드와 관련이 있다. 예를 들면 데이터베이스 쿼리를 다루는 코드 또는 웹 서비스 호출, 파일 읽기/쓰기를 말한다. 데이터 접근 객체(DAO)는 **인프라** 코드의 일부이다. 실제로 도메인 코드와 인프라 코드가 섞여 있을 때 시스템을 테스트하기 까다롭다. 가능한 이들을 분리해서 인프라가 테스트에 방해가 되지 않도록 해야 한다.


```
public class InvoiceFilter {
    private List<Invoice> all() { ❶
        try { 
            Connection connection = DriverManager.getConnection("db", "root", ""); ❷ 
            PreparedStatement ps = connection.prepareStatement("select * from invoice")); ❷ 
            Result rs = ps.executeQuery(); ❷
            
            List<Invoice> allInvoices = new ArrayList<>();
            while (rs.next()) { 
                allInvoices.add(new Invoice(
                    rs.getString("name"), rs.getInt("value")));
            }
        
            ps.close();
            connection.close();
        
            return allInvoices;
        } catch(Exception e) { ❸
            // 예외 처리
        }
    }

    public List<Invoice> lowValueInvoices() { ❹ 
        List<Invoice> issuedInvoices = all();
        return issuedInvoices.all().stream()
        .filter(invoice -> invoice.value < 100)
        .collect(toList());
    }
}
```

1. 이 메서즈는 모든 송장을 데이터베이스에서 직접 조회한다. 
2. 단순 SELECT 쿼리를 수행하는 JDBC 코드다. 
3. 데이터베이스 API는 종종 예외를 던진다.
4. lowValueInvoices 메서드는 앞에서 보았던 것과 같은 동작을 하지만, 이제는 데이터베이스에서 송장을 조회하기 위해 같은 클래스에 있는 메서드를 호출한다. 

위 클래스에는 다음과 같은 특징이 있다.

- **도메인 코드와 인프라 코드가 뒤섞여 있다.** 작은 값 송장 규칙을 테스트할 때 데이터베이스 접속을 피할 수 없다는 뜻이다. 퍼블릭 메서드드를 수행하면서 어떻게 프라이빗 메서드를 스텁으로 만들 수 있을까? 데이터베이스를 다루는 부분을 스텁으로 쉽게 만들 수 없다. 테스트를 작성할 때 이를 고려해야 한다.
- **책임이 클수록 더 복잡해지고 버그가 발생할 가능성이 증가한다.** 덜 응집된 클래스는 코드양이 많다. 코드양이 많다는 것은 버그가 발생할 확률이 크다는 뜻이다. 

코드를 괴롭히는 외부 요소는 인프라스트럭처만 있는 게 아니다. 사용자 인터페이스는 종종 도메인 코드와 섞여 있기도 한데, 이는 대부분 테스트 가능성을 해친다. 사용자 인터페이스가 시스템의 비즈니스 규칙을 수행하도록 하면 안 된다.

데이터베이스 접속과 같이 비즈니스 규칙을 다루는 응집력이 낮은 클래스를 테스트하는 것보다, 단일 책임을 지고 인프라 코드가 전혀 없는 클래스를 테스트하는 게 훨씬 쉽다. 단순한 코드에서는 확인할 사항이나 코너 케이스가 적다. 반면에 코드가 복잡하거나 더 많은 책임을 질수록 한 곳에 구현된 기능 간에 발생할 수 있는 상호작용과 테스트 케이스를 생각해야 한다. 예제에 있는 인프라 코드와 비즈니스 규칙 간의 상호작용은 단순하다. 메서드는 데이터베이스에서 송장을 검색하기만 하면 된다. 하지만 클래스가 더 복잡한 일을 수행하고 더 복잡한 인프라를 다루게 되면, 테스트와 유지 보수를 하는 일은 순식간에 악몽이 된다.

소프트웨어 시스템의 아키텍처는 **명확한 책임 분리**가 필요하다. 이를 간단하게 설명하면 **포트와 어댑터(또는 육각형 아키텍처)** 패턴으로 설명할 수 있다. 인프라에 직접 의존하기 보다는 **포트**를 사용하는 것이다. 애플리케이션은 인터페이스를 통해 다른 대상과 정보를 주고받을 수 있다. 포트는 인프라의 구현과 완전히 분리되어 있다. 반면에 **어댑터**는 인프라에 매우 가까이 있다. 어댑터는 포트의 구현체로서 데이터베이스나 웹 서비스 등과 통신하는 일을 한다. 어댑터는 인프라가 어떻게 동작하는지, 어떻게 통신해야 하는지를 알고 있다.

육각형 내부는 애플리케이션과 비즈니스 로직을 나타낸다. 이 영역의 코드는 애플리케이션의 비즈니스 로직 및 요구사항과 관련이 있다. 외부 시스템이나 필요한 인프라에 대해 전혀 알지 못한다. 하지만 애플리케이션은 어떤 정보가 필요하거나 외부와의 상호작용이 필요할 때가 있을 것이다. 애플리케이션은 직접 외부 시스템과 상호작용하지 않는다. 대신 포트를 이용해서 통신한다. 포트는 통신 기술과 무관해야 한다. 또한 애플리케이션의 관점에서, 포트는 통신 방법의 세부사항을 추상화해야 한다.

이 개념을 설명하는 간단한 예제가 있다. 다음과 같은 요구사항을 가진 온라인 쇼핑몰이 있다.

- 쇼핑 카트를 배송 준비 상태로 설정하고 새로운 상태를 데이터베이스에 영속화한다.
- 상품을 고객에게 전달해야 한다고 배송 센터에 알린다.
- SAP 시스템에 알린다.
- 고객에게 결제가 잘 이루어졌다는 이메일을 보낸다. 이메일은 배송 예상 날짜를 포함해야 한다. 이 정보는 배송 센터 API로 얻을 수 있다.

육각형 아키텍처를 적용하기 위한 첫 단계는 애플리케이션에 속한 것과 그렇지 않은 것을 구분하는 일이다. 상태 변경과 같은 ShoppingCart의 비즈니스 규칙뿐 아니라, 결제가 일어난 후 쇼핑 카트에 대한 전체 작업 흐름이 육각형 안에 속한다는 점은 분명하다. 하지만 이메일 전송 서비스, SAP와의 통신 서비스, 배송 센터 API로 통신하는 서비스 및 데이터베이스 통신 서비스는 모두 외부 시스템이 다루는 일이다. 우리는 외부 시스템과의 통신을 다루는 구현체와 통신하기 위한 명확한 인터페이스를 고안해야 한다.

`ShoppingCartRepository`, `DeliveryCartRepository`, `CustomerNotifier`, `SAP` 등의 외부 종속성을 인터페이스화하고 모든 의존성을 주입받도록 한다. 이는 테스트 도중 스텁과 모의 객체를 전달할 수 있다는 뜻이다. 

왜 이런 패턴을 사용하면 테스트 가능성을 개선할 수 있을까? 도메인 클래스가 포트에 의존하고 있으면 우리는 포트를 스텁과 모의 객체로 만들어서 도메인 로직의 동작을 쉽게 수행할 수 있다. 포트를 스텁이나 모의 객체로 만들어서 클래스의 주요 동작을 테스트하는 데 집중할 수 있다. 주입된 의존성이 제대로 동작하는지는 신경 쓰지 않는다. 해당 테스트를 위한 테스트 스위트가 있을 것이다. 

도메인 코드에서 인프라를 분리하는 개념은 콕번의 육각형 아키텍처뿐 아니라 소프트웨어 설계와 관련된 많은 자료에 나와 있다. 예를 들면 에릭 에반스의 도메인 주도 설꼐와 마틴의 클린 아키텍처와 같은 책이 있다. 이 원칙은 소프트웨어 설계 및 테스트 가능성을 논하는 사람들 사이에 널리 퍼져있다. 

**모든 포트에 대해 인터페이스를 만들어야 하나요?**란 질문에 대해 옳고 그른 것은 없다. 모든 것은 상황에 따라 다르며, 실용성이 관건이라는 것을 납득해야 한다. 이 책의 필자는 구현체가 두 개 이상이 되는 포트에 대해서는 인터페이스를 만든다. 또한 추상적 행위를 표현하는 인터페이스를 만들지 않을 때는, 구체적인 구현에서 구현 세부사항이 유출되지 않도록 한다. 언제나 문맥에 따라 판단하는 실용주의가 최고의 방법이다.

## 7.2 의존성 주입과 제어 가능성

애플리케이션(또는 도메인) 코드를 인프라 코드로부터 완전히 분리하도록 보장하는 것이 아키텍처 수준에서의 주요 관심사라는 것을 알았다. 이 책에서 권유하는 것은 클래스 수준에서 클래스를 완전히 **제어**할 수 있고, **관찰**할 수 있도록 해야 한다는 것이다.

- 제어: 테스트 대상 클래스의 행위를 쉽게 제어
- 관찰: 테스트 대상 크래스에서 무슨 일이 일어나는지 알 수 있고 출력 결과를 검사할 수 있도록

제어 가능성에 대한 일반적인 구현 전략은 만약 어떤 클래스가 다른 클래스에 의존한다면 의존성을 모의 객체, 페이크, 스텁 등으로 쉽게 교체할 수 있도록 하는 것이다. 생성자를 통한 의존성 주입 혹은 세터를 사용하면 이를 쉽게 구현할 수 있다. 

의존성 주입을 사용하면 여러 면에서 코드를 개선할 수 있다.

- 테스트 도중 의존성을 모의 객체나 스텁으로 만들 수 있게 해주고, 테스트 단계에서 생산성을 증대한다.
- 의존성을 더 명확하게 해준다. 의존성은 모두 주입할 필요가 있다.
- 관심사를 분리하기에 좋다. 클래스는 의존성을 어떻게 구축할지 걱정할 필요가 없다. 의존성이 주입되기 때문이다.
- 클래스가 더 확장성을 가지게 된다. 이 점은 테스트와는 무관하지만 클래스를 사용하는 클라이언트로서 생성자를 통해 어떤 의존성이라도 전달할 수 있다. 

의존성 역전 원칙(주입이 아니라 역전임에 유의)는 이러한 개념을 공식화하는 데 도움이 된다.

- (비즈니스 클래스 같은) 고수준 모듈은 저수준 모듈에 의존해서는 안 된다. 이 둘 모두는 추상화에 의존해야 한다.
- 추상화는 세부사항에 의존하면 안 된다. 세부사항은 추상화에 의존해야 한다.

추상화에 의존하는 것이 어떻게 테스트에 도움이 될까? 어떤 테스트를 단위 테스트할 때 의존성을 모의하거나 스텁으로 만들 것이다. 모의를 하면 자연스럽게 모의된 클래스가 계약으로 제공하는 것에 의존하게 된다. 모의하는 클래스가 복잡하면 할수록 테스트는 작성하기 힘들어진다. 포트, 어댑터, 의존성 역전 원칙을 염두에 두면 포트의 인터페이스는 자연스럽게 단순해진다. 

## 7.3 클래스 및 메서드를 관찰 가능하게 하기

클래스 수준에서의 관찰 가능성은 **기대했던 대로 동작하는지를 얼마나 쉽게 단언할 수 있는가**에 관한 것이다. 클래스에 자신의 상태를 단언할 수 있는 쉽고 간단한 방법이 있는지 확인하자. 클래스는 단언이 필요한 객체 목록을 하나씩 생성하는가? 그렇다면 클래스에 `getListOfSomething`메서드를 만들어서 테스트 도중 객체 목록을 생성해서 사용할 수 있도록 하자. 클래스가 다른 클래스를 호출하는가? 의존성을 모의하고 상호작용을 단언할 수 있도록 하자. 클래스가 내부에서 속성을 변경하는데 속성에 대한 게터를 제공할 수 없거나 하지 않고 있는가? 클래스에 간단한 isValid 메서드를 제공해서 클래스가 유효한 상태인지를 반환하자.

테스트 코드는 클래스의 행동을 쉽게 조사할 수 있어야 한다. 프로그램이 기대한 대로 동작하는 지 관찰하기 어렵다면 클래스가 관찰 가능한지를 생각해보자. 테스트 보조 수단으로서 단순 게터나 해결책을 도입하는 것을 마다하지 말자. 행위를 관찰하기 쉬우면 테스트 코드가 매우 쉬워진다.

### 7.3.1 단언을 보조하는 메서드 도입하기

테스트에 있는 단언문은 대부분 포트와의 상호작용에 관한 것이다. 이러한 단언문은 쉽게 만들 수 있고 모키토의 고급 기능을 필요로 하지 않는다. 객체의 상태를 확인하기 위해서는 모의 객체가 아닌 스파이로 만들어야 한다. 모키토 API를 이용하면 단 한 줄로 스파이 객체를 만들 수 있지만, 클래스의 행위를 단언하기 위한 스파이가 필요할 때마다 왜 스파이가 필요한지 자문해야 한다. 더 쉬운 방법은 없을까? 

클래스 내부에 상태를 나타내는 메서드를 추가해서 관찰 가능성을 높일 수 있다. 다만 단순하게 getter를 사용하는 것을 모든 관찰 가능성 이슈를 해결하기 위한 방법으로 사용해서는 안된다. 그렇게 하기보다는 추상화하자. 상태를 관찰하는 것이 스파이가 필요할 정도로 간단하지 않은 경우가 있고, 그 때 코드를 재평가해서 테스트 중에 배송 준비 상태를 쉽게 설정할 수 있는 방법을 찾을 때 이런 경우 게터가 손쉬운 구현 방법이 될 수 있다.

### 7.3.2 void 메서드의 행위를 관찰하기

어떤 메서드는 객체를 반환한다. 자연스럽게 단언문이 반환된 객체가 기대한 바와 같은지 검사할 것이라고 생각할 수 있다. 하지만 이런 생각은 void 메서드에 대해서는 자연스럽지 않다. 메서드가 어떤 것도 반환하지 않는다면 무엇을 단언해야 할까? 만약 단언하고자 하는 사항이 메서드에 포함되어 있다면 일은 더 복잡해진다. 

모키토를 사용한다면, ArgumentCaptor를 통해 모의 객체에 전달된 모든 인스턴스를 얻을 수 있다.

더욱 단순한 방법은 없을까? 만약 '생성된 모든 할부를 얻을 수 있는' 메서드가 있다면 테스트는 더 단순해질 것이다. void 메서드를 살짝 수정한다면, 반환값을 만들 수 있다. 그러나 이러한 방법을 그대로 받아들이기 보다는 테스트 가능성을 개선해주는 작은 설계 변경은 괜찮다는 점을 기억해야 한다. 가끔은 변경사항이 코드 설계를 망치지 않을지 판단하기 어려울 수 있는데, 시도해보고 마음에 들지 않으면 폐기하자. 실용주의가 핵심이다.

## 7.4 의존성 전달 방법: 클래스 생성자와 메서드 매개변수