# Chapter 1. 효율적이고 체계적인 소프트웨어 테스트

왜 테스트가 필요한가?

## 1.1 테스트를 하는 개발자와 하지 않는 개발자

**플래닝 포커 기능 구현 예시**

| 항목 | 설명 |
|--------|------|
| **메서드명** | identifyExtremes |
| **목적** | 추정 목록에서 최고/최저 추정값을 제시한 개발자 식별 |
| **입력** | Estimate 목록 (개발자 이름, 추정값) |
| **출력** | String 목록 (최저/최고 추정값 제시 개발자 이름) |

1. 가장 낮은 예측치와 높은 예측치를 저장할 변수를 선언한다.
2. 만약 현재 예측치가 현재까지의 가장 높은 예측치보다 더 높다면 현재 예측치로 바꾼다.
3. 만약 현재 예측치가 현재까지의 가장 낮은 예측치보다 더 낮다면 현재 예측치로 바꾼다.
4. 양극단의 예측치를 제시한 개발자를 반환한다. 

**테스트 코드를 작성하지 않는 개발자**

- 우연히 테스트 데이터가 오름차순으로 구현되어있다면, 테스트가 깨질 가능성이 있음
- lowestEstimate가 null을 반환

`직감을 따르는` 임시방편 테스트는 코너 케이스를 빼먹을 수 있다

**테스트 코드를 작성하는 개발자**

*Bad Weather 테스트*

- null 목록, 빈 목록, 하나의 요소만 가진 목록, 그리고 여러 요소를 가진 목록에 대한 테스트
- 유효하지 않은 입력을 거절하는 유효성 검사를 추가하고, 이에 대해 단언하는 테스트 코드 작성

*Good Weather 테스트*

- 프로그램이 올바르게 동작하는 테스트
- 하나보다 많은 추정 목록을 가진 목록을 전달하는 테스트
- 적어도 두 요소를 가진 리스트를 확인
    - 왜일까? 두 요소를 가진 목록은 함수가 정상 동작하는 가장 작은 목록으로, 동작하지 않는 한 요소만 가진 목록과 잘 동작하는 두 요소를 가진 목록 사이에 경계가 있음. **버그는 경계를 좋아한다.**
- 임의의 순서로 된 추정 목록을 메서드로 전달하는 테스트를 작성
    - 예시 기반 테스트(가능한 입력 중에서 하나의 특정 입력만 골라서 하는 테스트)가 아닌 **속성 기반 테스트**를 진행 (프레임워크를 이용하여 무작위로 생성한 추정 목록을 제공)
- 중복된 요소는 코드를 깨뜨릴 수 있다
    - 최고 추정 객체와 최저 추정 객체가 여러 개 있는 경우
    - 모든 추정이 같은 경우

## 1.2 개발자를 위한 효율적인 소프트웨어 테스트
- 도메인 테스트 : 요구사항을 작은 부분으로 나누어 테스트 케이스를 도출해내는 테스트 기법
- 일단 명세를 완성한 후, 코드에 초점을 맞추고 구조적 테스트를 통해 현재의 테스트 케이스가 충분한지 평가
- 몇몇 테스트 케이스에 대해서는 **예시 기반 테스트**를 작성하고, 특이한 경우에 대해서는 **속성 기반 테스트**를 사용

### 1.2.1 개발 과정에서의 효율적인 테스트
1. **요구사항**을 받는 것에서 시작. 요구사항은 대게 자연어로 작성되어 있고, UML 유스 케이스나 유저 스토리와 같은 특정 포맷을 따른다. 개발자는 어느 정도 이해(요구사항 분석)를 하고 나면, 코드를 작성하기 시작한다.
2. 기능 개발 유도를 위해 짧은 **테스트 주도 개발**을 반복. 이 반복 과정에서 자신이 작성한 코드가 타당한 지 피드백을 얻음.
3. 요구사항은 매우 크고 복잡할 경우 하나의 클래스나 메서드로 구현이 어려움. 결국 여러 단위를 만들게 되고, 각 단위는 다른 계약을 가지고 있고 서로 어울려 전체 기능을 구성하게 됨. 클래스를 테스트하기 쉽게 만드는 일은 어렵고, 개발자는 항상 **테스트 가능성**을 염두에 두고 설계해야 함.
4. 자신이 만든 단위에 만족하고, 요구사항을 충족한다고 생각할 경우 테스트를 작성한다. **도메인 테스트, 경계 테스트, 구조적 테스트 기법**을 적용한다.
5. 통합 테스트나 시스템 세스트와 같은 대규모 테스트가 필요한 부분이 있다.
6. 자동화된 지능형 테스트 도구를 사용하여, 사람이 잘 도출하지 못하는 케이스를 찾아낸다.


### 1.2.2 반복 프로세스로서의 효율적 테스트
- 순차적인 폭포수 프로세스처럼 들리지만, 매우 반복적인 행위
- 클래스를 엄격하게 테스트하다가 몇 시간 전에 작성한 코딩 결정사항이 이상적이지 않다는 것을 알아차릴 수 있음
- 다시 요구사항 분석으로 돌아가, 기댓값을 가다듬을 수 있으며 테스트 도중 버그를 발견하는 것은 매우 흔한 일
- 혹은 기능의 반만 구현하고 나머지를 구현하기 전에 테스트를 엄격하게 해보는 게 더 생산적이라고 느낄 수 있음

> 자신에게 가장 적합하고 생산적인 방식을 찾아야한다.

### 1.2.3 개발에 먼저 집중하고 나서 테스트하기
- (이 책의 저자의 경우) 코드 작성을 마치고 나면 테스트에 집중 
- 코드 작성을 마치고 나면 테스트에 집중, 체계적인 체크리스트를 따라가듯 다양한 기법을 따라함. 
- (체크 리스트를 가지고 있다면) 목록을 인수로 받을 때 무엇을 테스트할지에 대해 깊이 생각할 필요가 없음. 

### 1.2.4 '제대로 된 설계'에 대한 미신
- 코드가 단순해지도록 설계하면 미신이 없을 것이라는 인식
- 단순하고 냄새 없는 코드가 복잡한 코드보다 결함이 덜 발생한다는 실증이 있지만, 단순함으로는 턱없이 부족함
- 단순함이 테스트를 완전히 대체할 수 없음
- 코드를 더 잘 설계했다고 해서 발생할 수 있는 모든 버그를 피할 수는 없음

### 1.2.5 테스트 비용
- 이토록 엄격한 테스트를 하도록 강요하는 것은 너무 비용이 많이 든다고 생각할 수 있으나, 다음과 같은 가치를 가짐
    - 상용 버전에서 발생하는 버그의 비용은 종종 예방하는 비용보다 훨씬 크다.
    - 버그를 많이 만들어내는 팀은 개발자가 버그를 만들고 나서 고객이 버그를 발견하고 버그를 고치고 고객이 다시 다른 버그를 찾는 무한 루프에 시간을 많이 소모한다.
    - 연습이 관건이다. 일단 개발자들은 테스트 케이스를 작성하는 데 익숙해지면 더 빨리 작성할 수 있다.

### 1.2.6 효율적이면서 체계적이라는 것의 의미
- **효율적**이라는 말은 올바른 테스트를 작성하는 데 집중해야 함을 뜻함
    - 버그를 찾기 위해 들여야 하는 노력을 최소화하면서 최대한 많은 버그를 찾길 원한다. 
    - 어떻게? *무엇을 테스트해야 하는지 알면 된다.*
- **체계적**이라는 말은 어떤 코드 조각에 대해 어느 개발자라도 같은 테스트 스위트를 만들어낸다는 것을 의미
    - 프로세스를 체계화하여 그 일을 하는 개발자가 누가 되었든 상관없도록 할 수 있어야 한다.

### 1.2.7 테스트 자동화의 역할
- 테스트 케이스를 설계하는 것과 실행하는 것을 명확히 구분해야 함
- 소프트웨어 테스트 업무에 잇어 어려운 점은 JUnit 코드를 작성하는 것이 아니라 테스트 케이스가 버그를 드러내도록 제대로 설계하는 일

## 1.3 소프트웨어 테스트 원칙(테스트는 왜 이렇게 어려운가)
소프트웨어 테스터로서 우리 삶을 힘들게 하는 원칙과 그것을 완화하기 위한 원칙에 대해 다룬다.

### 1.3.1. 완벽한 테스트는 불가능하다
- 소프트웨어 시스템에 대한 테스트 조합은 우주에 존재하는 원자 개수보다 더 많음
- 모든 걸 테스트하는 것이 불가능하니, 개발자는 **무엇을 테스트할지 선택해야 한다.**
- **효율적인 테스트**가 필요하다고 강조하는 이유이다.

### 1.3.2 테스트를 그만둘 때를 파악하기
- 명확한 가정 없이 계속 테스트를 작성하는 것은 비효율적인 테스트가 될 수 있다
- 우리의 목표는 항상 비용을 최소화하면서 최대한 많이 버그를 찾는 것이다.

### 1.3.3 가변성이 중요하다(살충제 역설)
- 가능한 버그를 모두 찾기 위해 한 가지의 기법만 사용할 수는 없음
- 다른 종류의 버그를 찾는 데에는 다른 테스트 기법이 도움이 됨.
- 구체적인 예로는, 단위 테스트에만 의존하는 팀을 들 수 있음.

### 1.3.4 버그는 다른 곳에 비해 많이 발생하는 지점이 있다
- 앞서 언급했 듯, 완벽한 ㅔㅌ스트는 불가능하기 때문에 소프트웨어 테스터는 수행할 테스트에 우선순위를 매겨야함.
- 버그는 균일하게 분포되어있지 않고, 몇몇 구성요소에는 다른 구성요소보다 더 많은 버그가 있다
- 이를 **결함 클러스터링**이라고 한다.

### 1.3.5 어떤 테스트를 하든지 결코 완벽하거나 충분하지 않다.
- 단순히 테스트를 많이 해서 버그를 더 찾을 수는 있지만, 테스트가 얼마나 대량으로 진행되든지 간에 소프트웨어 시스템에 버그가 100% 존재하지 않다는 것을 보장할 수 없다.
- 하지만 테스트와 에방책에 쏟아부은 돈은 영향력이 덜한 버그만 통과하도록 값어치를 할 것이다.
