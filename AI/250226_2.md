# Part 3. 프롬프트 엔지니어링 기초

프롬프트 엔지니어링 과정은 다음과 같은 5단계로 세분화할 수 있다.

1. **프롬프트 결과 설정**
  먼저 원하는 답변이나 결과의 유형을 명확히 정의한다. 이 단계에서는 최종적으로 얻고자 하는 정보의 종류와 형태를 결정한다.
2. **프롬프트 평가 설계**
  설정한 목표를 달성하고자 할 때 프롬프트의 효과를 어떻게 평가할지에 대한 기준을 마련한다. 이는 프롬프트가 원하는 결과를 얼마나 잘 도출해 내는지 측정하는 메커니즘을 개발하는 것을 포함한다. 업무에 본격적으로 사용할 때는 프롬프트를 반복적으로 사용하여 업무를 자동화하는 것을 목표로 한다. 따라서 이 과정이 가장 중요하다.
3. **그라운딩 설계 및 평가**
  그라운딩은 AI가 답변을 생성할 . 때신뢰할 수 있는 정보나 데이터에 기반하여 정확성과 연관성을 확보하는 과정이다. 이 단계에서는 모델이 참조할 기초 데이터나 사실들을 정리한다.
4. **프롬프트 디자인**
  앞서 정의한 목표와 평가 기준에 따라 실제 프롬프트를 설계한다. 이 단계는 창의성과 실험적 접근이 필요하며, 여러 시도를 통해 최적의 프롬프트 구조를 찾아간다.
5. **모니터링 및 개선**
  원하는 목적을 달성하는 프롬프트를 잘 만들었다면 이를 실제 업무에 반영한다. 프롬프트가 실제 환경에서 사용되는 동안에는 지속적으로 성능을 모니터링하고 필요한 경우에는 개선하는 것이 중요하다. 여기에는 사용자의 피드백을 반영하고 새로운 데이터나 정보가 등장했을 때 프롬프트를 업데이트하여 최신 상태를 유지하는 과정이 포함된다.

## 프롬프트 테크닉

### 자기 일관성

자기 일관성은 CoT보다 AI가 더 정확하고 신뢰할 수 있는 답변을 제공하도록 설계된 기법으로, 동일한 문제에 대해 여러 가지 다른 추론 경로를 고려한 후 가장 일관되게 나온 답을 선택한다. 이는 마치 여러 사람에게 각자 해결 방안을 생각해 보라고 한 뒤 가장 반복적으로 나온 답을 선택하는 과정과 유사하다.

자기 일관성의 수행 능력을 측정하는 논문 실험 결과, 약 20개 정도의 예제를 주는 것이 가장 효과적인 것으로 나타났다.  
자기 일관성 측정 지표에는 `temperature`, `top-k`라는 용어가 나오는데 이는 각각 다음과 같은 의미를 가진다.

- T(Temperature): T 값이 낮을수록 높은 확률을 가진 경로를 위주로 선택할 가능성이 커지며, 더 높은 T 값은 더 다양한 경로를 탐색할 가능성이 높다.
- K(top-k 샘플링): 이는 모델이 다음 단계에서 고려할 수 있는 가능한 경로의 최대 수를 제한한다. 예를 들어 k=40은 다음 단계에서 최대 40개의 경로를 고려한다는 것을, 'no top k'는 top-k 샘플링을 사용하지 않았음을 의미한다.

### 샘플링 투표

샘플링 투표는 자기 일관성과 개념적으로 유사하지만 몇 가지 차이점이 있다.

- 복잡한 CoT 프롬프팅 대신 기본적인 지시를 사용하고 출력을 가공 없이 활용한다.
- 단순히 출력 간 유사도를 계산하여 다수결로 답안을 선정한다.
- 추론 작업뿐만 아니라 코드 생성 등 다양한 작업에 대해 일반화된 접근법이다.
- 자기 일관성과 결합하여 상호 보완적으로 활용할 수 있다.

샘플링 단계에서는 작업에 대한 질의 혹은 지시를 LLM에게 N번 반복하여 출력 샘플을 다양하게 생성한다. 이 때 다양한 출력을 얻기 위해 별도의 페르소나를 설정하거나 서로 다른 LLM 모델을 사용할 수도 있지만, 별도의 페르소나 설정 없이도 동일한 입력에 대해 같은 LLM을 단순히 반복 실행하는 방식을 사용해도 된다.

다수결 투표를 통해 이 샘플들 중 가장 일관성 있는 출력을 최종 답변으로 선택한다. 투표 단계에서는 각각의 샘플에 대한 다른 모든 샘플과의 유사도를 계산하여 누적된 유사도 점수를 구한다. 유사도는 임베딩 벡터로 계산하거나 BLEU 점수 등을 사용한다. 객관식 문제에서는 답안의 출현 빈도수로 유사도 누적 점수를 계산한다. 이를 통해 가장 높은 누적 유사도를 얻은 샘플을 최종 답변으로 선택한다.

샘플링 투표 방식의 가장 큰 장점은 기존의 복잡한 프롬프트 설계나 에이전트 협업 체계 없이도 그에 비견될만한 성능을 낼 수 있다는 점이다. 더 놀라운 점은 앙상블 규모를 충분히 늘리면 작은 LLM이 더 큰 모델의 단일 출력 성능을 능가할 수 있다는 것이다. 

### 최소에서 최대로

하나의 문제를 더 작은 여러 개의 하위 작업으로 분할하는 기법을 의미한다. '`주어진 문제`를 풀려면 먼저 다음 묹를 풀어야합니다.'라는 프롬프트로 다음 문제를 생성하고, 해당 질문을 통해 답을 생성하는 과정을 최종 답변이 생성될 때까지 반복한다. 하위 작업들은 한 번에 하나씩 해결되며, 이전에 생성한 답은 다음 문제를 해결하는 데 사용한다. 

### 자기 평가

자기 평가 기법은 LLM이 생성한 결과를 LLM 스스로 평가하게 하여 오류를 잡거나 결과를 향상시키는 기법이다. AI가 단순히 주어진 데이터를 바탕으로 정보를 생성하고 제공하는 것을 넘어 그 결과의 정확성을 스스로 검토하고 보정하는 능력을 갖추게 된 후 본격적으로 사용되었다.  
자기 평가 기법은 어떤 고정된 형태의 프레임워크가 존재하는 것은 아니다. 스스로 평가한다는 개념으로 자기 비판, 원칙 기반 AI 등 다양한 방식으로 으용될 수 있다. 따라서 자동 프롬프트 엔지니어나 자율 실행 에이전트와 같이 AI가 스스로를 평가하고 향상시키는 기술에 많이 사용된다.  
다만, 아직까지는 GPT-4 수준의 높은 성능을 가진 LLM 정도만 의미 있는 평가를 할 수 있으므로, 당분간은 사용 범위에 상당한 제약이 있을 것으로 보인다. 

## 프롬프트 확장 테크닉: 예시를 제공하고 생각하게 만들기

- **전문가 역할 프롬프팅**: 프롬프트 설계에서 역할을 설정하는 것과 동일한 방법으로, LLM에게 전문가로서 응답하도록 요청하는 방법
- **위키디피아에 따르면**: 단순히 `위키디피아를 참조해서 답하세요`라고 하는 것만으로도 높은 성능을 얻을 수 있는 기법
- **지식 생성 프롬프팅**: 주어진 질문에 대한 관련 지식을 먼저 생성하라고 한 다음, 생성한 지식을 바탕으로 답변을 생성하는 기법. 어떤 질문이 주어지면 LLM이 먼저 해당 질문과 관련된 지식 조각들을 다양하게 생성하고, 이러한 지식 조각들을 통합한 뒤 정보화하여 질문에 대한 최종 답변을 생성함. 단, 생성 AI의 특성상 아주 정확한 지식을 생성한다는 보장은 없으므로 생성 결과를 주의 깊게 평가할 필요가 있음.
- **검색 증강 생성(RAG)**: RAG란 답변을 생성하기 전에 사용자의 요청과 관련된 지식을 외부 검색 컴포넌트에서 검색한 후 해당 내용을 프롬프트에 컨텍스트로 제공하여 결과를 생성하는 기법으로, 답변의 정확도를 극도로 높이기 위한 가장 좋고 확실한 방법으로 프롬프트 엔지니어링의 필수적인 구성 요소가 됨. 이에 따라 벡터 서치가 매우 중요한 구성 요소로 자리잡게 되었다.

## 프롬프트 확장 테크닉: 전략을 짜고 스스로 평가하기

### 생각 트리

트리 구조로 답변을 생성해 내면서 중간 단계에서 진행 상황을 스스로 평가하여 생각 트리를 확장하고 선택하는 방법. 생성한 결과와 평가를 통해 앞뒤로 생각을 체계적으로 탐색하여 매우 높은 수준의 사고를 할 수 있도록 한다.

다른 프롬프팅 기법과 비교해보면,

- **입출력 프롬프팅**: 가장 간단한 형태로, 질문에 대한 답변을 직접적으로 생성
- **생각 사슬 프롬프팅**: 질문에 답하기 위해 중간 단계의 추론을 먼저 생성
- **자기 일관성 프롬프팅**: 여러 추론 경로를 고려하여 가장 일관된 답변을 선택
- **생각 트리 프롬프팅**: 여러 단계의 추론 경로를 탐색하며 최적의 추론 경로를 찾아나감

여기서 트리란 문제 해결 과정에서 각각의 추론 단계가 마치 나무의 가지처럼 갈라지면서 뻗어나가는 구조를 의미함. 각각 가지는 가능한 생각의 경로를 나타내며, 나무 전체는 모든 가능한 추론의 경로를 나타냄. 트리 구조를 통해 다양한 추론 경로 중에서 최적의 경로를 선택하여 정교하고 체계적인 최종 답변을 찾아감. 이 과정에서 생성된 여러 경로는 복잡한 문제에 대한 해답을 찾는 데 있어 다차원적인 사고를 가능하게 함.

생각 트리는 매우 많은 성능 단계를 거치기에 일반적으로 사용하기는 어렵지만, 고도의 생성 전략이 필요한 경우 다른 프롬프트 엔지니어링 기법들과 혼합해 사용하면 극도로 높은 성능을 기대할 수 있음

### 계획 - 풀이 프롬프팅

생각 사슬, 자기 일관성 등의 기법을 사용했을 때 잘못된 답변을 하는 경우 가장 큰 문제는 중간 문제 풀이 단계가 누락되는 경우가 있다는 것.
계획-풀이 프롬프팅은 이러한 단계 누락의 오류를 해결하기 위한 기법으로, 전체 작업을 더 작은 하위 작업으로 계획을 세우고 그 계획에 따라 하위 작업을 수행하거나 평가하면서 전체 문제를 해결함.

최소에서 최대로 기법이 풀어야 할 문제를 단계적으로 생성해가면서 문제를 푼다면, 계획-풀이 프롬프팅은 미리 풀어야 할 하위 문제를 모두 생성해 두고 문제를 푼다는 것이 다른점임.

- **ex. 어떤 사람의 몸무게를 알아내기 위한 풀이 방법을 생성할 때**
한 사람의 무게를 기준으로 또 다른 사람의 무게를 함수로 표현하여 문제를 체계적으로 분해한다. 단순히 문제를 단계적으로 푸는 것만이 아니라 변수 설정부터 계획 수립, 계산 수행 그리고 최종 해답 제시에 이르기까지 필요한 조건과 과정이 명확하게 기술됨. 이 과정을 먼저 진행하면 관련 변수들 간의 관계를 더 잘 이해할 수 있어 구조화된 분석이 가능하다.

### 자동 프롬프트 엔지니어

자동 프롬프트 엔지니어는 LLM이 프롬프트를 자동으로 생성하는 기법으로, 원하는 작업에 대한 출력 예시를 주고 해당 작업을 잘 수행할 수 있는 프롬프트를 다양하게 생성하고 이를 채점하여 가장 높은 점수를 받은 프롬프트를 사용하는 방식이다.

`LLM as Inference Model`, `LLM as Scoring Model`, `LLM as Resampling Model`을 활용한다. 

추론에게 응답 예시를 제공하고 이를 토대로 프롬프트를 생성한다. 그 다음, 스코어링 모델을 통해 생성된 프롬프트를 테스트 데이터로 넣어 각각의 프롬프트에 대한 점수를 로그 확률로 출력한다. 마지막으로 리샘플링 모델을 통해 점수가 높은 프롬프트에 대해 의미를 유지하면서 다시 다양한 형태의 프롬프트를 생성한다. 그리고 이렇게 생성한 프롬프트들을 다시 평가하여 최종적으로 가장 점수가 높은 프롬프트를 선택한다.

단, 이 방식은 완전한 프롬프트를 처음부터만들어 내기에는 아직 한계가 있다. 따라서 기본 프롬프트를 작성한 뒤 성능을 더 끌어올리기 위한 파인 튜닝의 개념으로 많이 사용한다.

----

지금까지 학습한 다양한 프롬프트 기법의 핵심은 다음 네 가지로 정리할 수 있다.

1. **예시를 제공한다.**
2. **생각을 많이 하게 한다.**
3. **문제 풀이 전략을 세우게 한다.**
4. **스스로 평가한다.**

만약 프롬프트를 작성하다가 결과가 잘 안 나온다면 이 네 가지 중 어떤 항목이 빠져 있거나 부족한지 살펴보면 더 좋은 프롬프트를 만들 수 있을 것이다.

## 프롬프트 체이닝

프롬프트 체이닝이란 일련의 프롬프트와 그에 따른 응답을 순서대로 연결하여 하나의 지속적인 대화나 여러 하위 태스크로 이루어진 복잡한 태스크를 수행하는 기법이다. 앞서 언급한 자기 일관성, 선택 추론, 최소에서 최대로, 리액트 등 고수준의 프롬프트 엔지니어링은 거의 모두 이 프롬프트 체이닝을 사용한다.

### 단순 프롬프트 연결하기

답변과 질문을 순차적으로 진행하면서 프롬프트를 연결하는 것이 가장 기초적인 체이닝이다.

1. 컨텍스트와 질문을 제공한다.
2. 질문에 필요한 내용을 컨텍스트에서 추출해 나열한다.
3. 추출한 내용에 `Selection:`이라는 제목을 넣어준다.
4. `Selection`과 질문을 기반으로 답변을 하도록 요구하면 정확한 답변을 할 수 있다.

### 이전 결과에 따른 분기 처리하기

사용자의 입력 유형이나 출력 결과의 유형에 따라 다른 방식으로 결과를 도출하도록 유도한다.

### 결과 내 유사 체이닝 효과 주기

일종의 CoT 방식을 답변 안에서 진행하는 방법으로, 프롬프트를 여러 단계로 구성하지 않아도 간단하게 LLM이 생각하도록 만드는 효과를 줄 수 있다. 결과 또한 구조화된 JSON 포맷으로 받기 때문에 정확도나 결과에 대한 예측 가능성이 높아지고, 이를 프로그램에도 쉽게 반영할 수 있다는 장점이 있다.

