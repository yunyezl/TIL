# 단위 테스트 안티 패턴

## 1. 비공개 메서드 단위 테스트

- 단위 테스트를 위해 비공개 메서드를 노출하는 경우는 단위 테스트 원칙인 `식별할 수 있는 동작만 테스트하는 것`을 위반함.
- 테스트가 구현 세부 사항과 결합되고 결과적으로 리팩터링 내성이 떨어짐.
- 비공개 메서드가 타당한 경우
  - 비공개 메서드를 절대 테스트하지 말라는 규칙에도 예외가 있음
  - 예로, 관리자가 조회를 하나씩 검토하고 승인 여부를 결정하는 `Inquiry` 클래스
  - ORM 라이브러리에 의해 데이터베이스에서 클래스가 복원되므로 비공개 생성자를 가지지만, 단위 테스트를 거쳐야함.
  - 이 것이 비공개이면서 식별할 수 있는 메서드 동작의 예

## 2. 비공개 상태 노출

- 단위 테스트를 위해 비공개 상태를 노출하는 것
- 제품 코드가 이 비공개 상태를 어떻게 사용하는지를 대신 살펴봄으로써 테스트 가능함

## 3. 테스트로 유출된 도메인 지식

- 알고리즘 테스트를 할 때 같은 코드를 복사하는 것이 아니라, 기댓값을 함께 넘기는 것이 좋음

## 4. 코드 오염

- 코드 오염은 테스트에만 필요한 제품 코드를 추가하는 것
- `Logger`의 예시를 들면, 클래스가 운영 환경에서 실행되는지 여부를 나타내는 생성자 매개변수를 받아 이 값에 따라 스위치하는 로직이 들어감
- 코드 오염의 문제는 테스트 코드와 제품 코드가 혼재돼 유지비가 증가하는 것
  - `Logger`의 경우 인터페이스화하여 제품 로거와 테스트 로거를 별도로 주입하는 것이 좋음

## 5. 구체 클래스를 목으로 처리하기

- 일부 기능을 지키기 위해 구체 클래스를 목으로 처리해야 하면, 이는 단일 책임 원칙을 위반하는 결과
- 비관리 의존성과 통신하는 책임을 별도 클래스로 분리하여 목 처리

## 6. 시간 처리하기

- 많은 애플리케이션이 날짜와 시간에 대한 접근이 필요함
- 그러나 시간에 따라 달라지는 기능을 테스트하면 거짓 양성이 발생할 수 있음
- 앰비언트 컨텍스트로서의 시간 : 제품 코드를 오염시키고 테스트를 어렵게 함
- 명시적 의존성으로서의 시간 : 서비스 또는 일반 값으로 의존성을 명시적 주입